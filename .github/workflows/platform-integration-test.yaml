name: Platform Integration Test

# Full end-to-end test: Creates ephemeral cluster, bootstraps platform, validates health
# This replaces all other validation workflows with one comprehensive test

on:
  pull_request:
    paths:
      - 'platform/**'
      - 'bootstrap/**'
      - 'scripts/**'
  workflow_dispatch:

env:
  K3D_VERSION: v5.6.0
  KUBECTL_VERSION: v1.28.0
  ARGOCD_VERSION: v2.9.3

jobs:
  integration-test:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install k3d
        run: |
          curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | TAG=${{ env.K3D_VERSION }} bash

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/

      - name: Create k3d test cluster
        run: |
          echo "Creating k3d cluster for integration testing..."
          k3d cluster create test-platform \
            --agents 1 \
            --wait \
            --timeout 5m
          
          kubectl cluster-info
          kubectl get nodes

      - name: Install ArgoCD using bootstrap script
        run: |
          echo "Installing ArgoCD using existing bootstrap script..."
          
          # Make script executable
          chmod +x scripts/bootstrap/03-install-argocd.sh
          
          # Run the script
          ./scripts/bootstrap/03-install-argocd.sh
          
          echo "✓ ArgoCD installed successfully"

      - name: Label k3d nodes for workload placement
        run: |
          echo "Labeling k3d nodes to support workload selectors..."
          
          # Label all nodes with intelligence workload label
          kubectl label nodes --all workload.bizmatters.dev/intelligence=true --overwrite
          
          echo "✓ Nodes labeled for workload placement"

      - name: Configure ArgoCD to use feature branch
        run: |
          echo "Configuring ArgoCD to sync from feature branch: ${{ github.head_ref }}"
          
          # Update platform apps to point to PR branch
          for file in platform/*.yaml; do
            if [ -f "$file" ] && [ "${file##*.}" = "yaml" ] && [[ ! "$file" =~ \.disabled$ ]]; then
              echo "Updating $file to use branch: ${{ github.head_ref }}"
              sed -i "s|targetRevision:.*|targetRevision: ${{ github.head_ref }}|g" "$file"
            fi
          done
          
          echo "✓ Platform apps configured for feature branch"

      - name: Deploy platform root application
        run: |
          echo "Deploying platform root application..."
          
          # Apply root application
          kubectl apply -f bootstrap/root.yaml
          
          echo "✓ Root application deployed"
          
          # Give ArgoCD time to detect applications
          sleep 10
          
          echo "ArgoCD Applications:"
          kubectl get applications -n argocd

      - name: Wait for external-secrets namespace to be created
        run: |
          echo "Waiting for ArgoCD to create external-secrets namespace..."
          
          TIMEOUT=120
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if kubectl get namespace external-secrets &>/dev/null; then
              echo "✓ external-secrets namespace exists"
              break
            fi
            echo "Waiting for external-secrets namespace... (${ELAPSED}s / ${TIMEOUT}s)"
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "✗ Timeout waiting for external-secrets namespace"
            exit 1
          fi

      - name: Inject ESO bootstrap secret using bootstrap script
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          echo "Injecting ESO bootstrap secret using existing script..."
          
          # Make script executable
          chmod +x scripts/bootstrap/05-inject-secrets.sh
          
          # Run the script with AWS credentials
          ./scripts/bootstrap/05-inject-secrets.sh "$AWS_ACCESS_KEY_ID" "$AWS_SECRET_ACCESS_KEY"
          
          echo "✓ ESO bootstrap secret created"

      - name: Verify ESO is working
        run: |
          echo "Verifying External Secrets Operator is working..."
          echo ""
          
          # Wait for ESO pods to be ready
          echo "Waiting for ESO pods to be ready..."
          kubectl wait --for=condition=ready pod \
            -l app.kubernetes.io/name=external-secrets \
            -n external-secrets \
            --timeout=120s
          
          echo "✓ ESO pods are ready"
          echo ""
          
          # Wait for ClusterSecretStore to be ready
          echo "Waiting for ClusterSecretStore to be ready..."
          TIMEOUT=120
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            STORE_STATUS=$(kubectl get clustersecretstore aws-parameter-store -o jsonpath='{.status.conditions[0].status}' 2>/dev/null || echo "Unknown")
            
            if [ "$STORE_STATUS" = "True" ]; then
              echo "✓ ClusterSecretStore is ready"
              break
            fi
            
            echo "ClusterSecretStore status: $STORE_STATUS (${ELAPSED}s / ${TIMEOUT}s)"
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "✗ Timeout waiting for ClusterSecretStore"
            kubectl describe clustersecretstore aws-parameter-store
            exit 1
          fi
          
          echo ""
          echo "ClusterSecretStore status:"
          kubectl get clustersecretstore aws-parameter-store
          echo ""
          
          # Wait for ExternalSecrets to sync
          echo "Waiting for ExternalSecrets to sync..."
          TIMEOUT=120
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            # Check if any ExternalSecrets exist
            ES_COUNT=$(kubectl get externalsecret -A --no-headers 2>/dev/null | wc -l | tr -d ' ')
            
            if [ "$ES_COUNT" -gt 0 ]; then
              # Check if all are synced
              SYNCED=$(kubectl get externalsecret -A -o json | jq '[.items[] | select(.status.conditions[0].status == "True")] | length')
              
              if [ "$SYNCED" -eq "$ES_COUNT" ]; then
                echo "✓ All $ES_COUNT ExternalSecrets are synced"
                break
              fi
              
              echo "ExternalSecrets synced: $SYNCED/$ES_COUNT (${ELAPSED}s / ${TIMEOUT}s)"
            else
              echo "No ExternalSecrets found yet... (${ELAPSED}s / ${TIMEOUT}s)"
            fi
            
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          echo ""
          echo "ExternalSecret status:"
          kubectl get externalsecret -A
          echo ""
          
          # Verify secrets were created
          echo "Verifying secrets were created:"
          
          if kubectl get secret kagent-openai -n kagent &>/dev/null; then
            echo "✓ Secret kagent-openai exists in kagent namespace"
          else
            echo "⚠️  Secret kagent-openai not found in kagent namespace"
          fi
          
          if kubectl get secret kagent-openai -n intelligence-platform &>/dev/null; then
            echo "✓ Secret kagent-openai exists in intelligence-platform namespace"
          else
            echo "⚠️  Secret kagent-openai not found in intelligence-platform namespace"
          fi
          
          echo ""
          echo "✓ ESO verification complete"

      - name: Wait for ArgoCD to sync all applications
        run: |
          echo "Waiting for all ArgoCD applications to sync (timeout: 15 minutes)..."
          
          # Load ignore list
          IGNORE_APPS=()
          if [ -f ".github/ci-ignore-apps.txt" ]; then
            echo "Loading CI ignore list..."
            while IFS= read -r line; do
              # Skip comments and empty lines
              [[ "$line" =~ ^#.*$ ]] && continue
              [[ -z "$line" ]] && continue
              # Extract app name (before any comment)
              app=$(echo "$line" | sed 's/#.*//' | xargs)
              [[ -n "$app" ]] && IGNORE_APPS+=("$app")
            done < ".github/ci-ignore-apps.txt"
            
            if [ ${#IGNORE_APPS[@]} -gt 0 ]; then
              echo "Ignoring apps: ${IGNORE_APPS[*]}"
            fi
          fi
          echo ""
          
          TIMEOUT=900
          ELAPSED=0
          CHECK_INTERVAL=15
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            echo ""
            echo "=== Checking application status (${ELAPSED}s / ${TIMEOUT}s) ==="
            
            # Get all applications
            APPS=$(kubectl get applications -n argocd -o json)
            TOTAL=$(echo "$APPS" | jq -r '.items | length')
            
            if [ "$TOTAL" -eq 0 ]; then
              echo "No applications found yet, waiting..."
              sleep $CHECK_INTERVAL
              ELAPSED=$((ELAPSED + CHECK_INTERVAL))
              continue
            fi
            
            # Count synced and healthy apps
            SYNCED=0
            HEALTHY=0
            PROGRESSING=0
            FAILED=0
            
            echo "$APPS" | jq -r '.items[] | "\(.metadata.name)|\(.status.sync.status // "Unknown")|\(.status.health.status // "Unknown")"' | while IFS='|' read -r name sync health; do
              echo "  $name: $sync / $health"
              
              if [ "$sync" = "Synced" ]; then
                SYNCED=$((SYNCED + 1))
              fi
              
              if [ "$health" = "Healthy" ]; then
                HEALTHY=$((HEALTHY + 1))
              elif [ "$health" = "Progressing" ]; then
                PROGRESSING=$((PROGRESSING + 1))
              elif [ "$health" = "Degraded" ] || [ "$health" = "Missing" ]; then
                FAILED=$((FAILED + 1))
              fi
            done
            
            # Build jq filter to exclude ignored apps
            IGNORE_FILTER=""
            for ignore_app in "${IGNORE_APPS[@]}"; do
              IGNORE_FILTER="$IGNORE_FILTER and .metadata.name != \"$ignore_app\""
            done
            
            # Check sync status (excluding ignored apps)
            ALL_SYNCED=$(echo "$APPS" | jq "[.items[] | select(true $IGNORE_FILTER) | select(.status.sync.status != \"Synced\")] | length")
            CHECKED_TOTAL=$(echo "$APPS" | jq "[.items[] | select(true $IGNORE_FILTER)] | length")
            
            # Check health status (ALL apps including ignored - they must still be healthy!)
            ALL_HEALTHY=$(echo "$APPS" | jq '[.items[] | select(.status.health.status != "Healthy" and .status.health.status != "Progressing")] | length')
            
            # Warn if any ignored apps are unhealthy (but don't fail yet, keep looping)
            if [ ${#IGNORE_APPS[@]} -gt 0 ]; then
              IGNORED_UNHEALTHY=$(echo "$APPS" | jq -r "[.items[] | select(true and .metadata.name == \"${IGNORE_APPS[0]}\"$(for i in "${IGNORE_APPS[@]:1}"; do echo " or .metadata.name == \"$i\""; done)) | select(.status.health.status != \"Healthy\" and .status.health.status != \"Progressing\")] | .[].metadata.name")
              
              if [ -n "$IGNORED_UNHEALTHY" ]; then
                echo ""
                echo "⚠️  WARNING: Ignored apps should still be Healthy!"
                echo "Unhealthy ignored apps:"
                while read -r app; do
                  if [ -n "$app" ]; then
                    HEALTH=$(kubectl get application $app -n argocd -o jsonpath='{.status.health.status}')
                    echo "  - $app: $HEALTH (waiting...)"
                  fi
                done <<< "$IGNORED_UNHEALTHY"
              fi
            fi
            
            echo ""
            if [ ${#IGNORE_APPS[@]} -gt 0 ]; then
              echo "Summary: $TOTAL total applications ($CHECKED_TOTAL checked for sync, $((TOTAL - CHECKED_TOTAL)) ignored)"
            else
              echo "Summary: $TOTAL total applications"
            fi
            echo "  Synced: $(($CHECKED_TOTAL - $ALL_SYNCED))/$CHECKED_TOTAL (checked apps)"
            echo "  Healthy: $(($TOTAL - $ALL_HEALTHY))/$TOTAL (all apps including ignored)"
            
            # Show detailed info for OutOfSync or unhealthy apps
            echo ""
            echo "=== Detailed Status for Non-Synced/Unhealthy Apps ==="
            
            # OutOfSync apps (excluding ignored)
            OUTOF_SYNC=$(echo "$APPS" | jq -r "[.items[] | select(true $IGNORE_FILTER) | select(.status.sync.status != \"Synced\")] | .[].metadata.name")
            if [ -n "$OUTOF_SYNC" ]; then
              echo ""
              echo "OutOfSync Applications:"
              while read -r app; do
                if [ -n "$app" ]; then
                  echo ""
                  echo "--- $app (OutOfSync) ---"
                  
                  # Get sync status details
                  SYNC_STATUS=$(kubectl get application $app -n argocd -o json | jq -r '.status.sync.status // "Unknown"')
                  SYNC_REVISION=$(kubectl get application $app -n argocd -o json | jq -r '.status.sync.revision // "Unknown"')
                  
                  echo "Sync Status: $SYNC_STATUS"
                  echo "Revision: $SYNC_REVISION"
                  
                  # Show diff/reason
                  echo "Sync Comparison Result:"
                  kubectl get application $app -n argocd -o json | jq -r '.status.operationState.syncResult // .status.conditions[] | select(.type == "ComparisonError") | .message' 2>/dev/null || echo "No comparison details available"
                  
                  # Show recent operation
                  echo "Recent Operation:"
                  kubectl get application $app -n argocd -o json | jq -r '.status.operationState.message // "No recent operation"'
                fi
              done <<< "$OUTOF_SYNC"
            fi
            
            # Unhealthy apps (excluding ignored)
            UNHEALTHY=$(echo "$APPS" | jq -r "[.items[] | select(true $IGNORE_FILTER) | select(.status.health.status != \"Healthy\" and .status.health.status != \"Progressing\")] | .[].metadata.name")
            if [ -n "$UNHEALTHY" ]; then
              echo ""
              echo "Unhealthy Applications:"
              while read -r app; do
                if [ -n "$app" ]; then
                  echo ""
                  echo "--- $app (Unhealthy) ---"
                  
                  # Get health status details
                  HEALTH_STATUS=$(kubectl get application $app -n argocd -o json | jq -r '.status.health.status // "Unknown"')
                  HEALTH_MESSAGE=$(kubectl get application $app -n argocd -o json | jq -r '.status.health.message // "No message"')
                  
                  echo "Health Status: $HEALTH_STATUS"
                  echo "Health Message: $HEALTH_MESSAGE"
                  
                  # Show unhealthy resources
                  echo "Unhealthy Resources:"
                  kubectl get application $app -n argocd -o json | jq -r '.status.resources[] | select(.health.status != "Healthy") | "  - \(.kind)/\(.name): \(.health.status) - \(.health.message // "no message")"' 2>/dev/null || echo "  No resource details available"
                fi
              done <<< "$UNHEALTHY"
            fi
            
            if [ "$ALL_SYNCED" -eq 0 ] && [ "$ALL_HEALTHY" -eq 0 ]; then
              echo ""
              echo "✓ All applications synced and healthy!"
              break
            fi
            
            # Show pods status for debugging
            echo ""
            echo "Non-Running Pods:"
            kubectl get pods -A --field-selector=status.phase!=Running,status.phase!=Succeeded 2>/dev/null || echo "  All pods are running"
            
            sleep $CHECK_INTERVAL
            ELAPSED=$((ELAPSED + CHECK_INTERVAL))
          done
          
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo ""
            echo "✗ Timeout waiting for applications to sync"
            echo ""
            echo "Application details:"
            kubectl get applications -n argocd
            echo ""
            echo "Describing failed applications:"
            kubectl get applications -n argocd -o json | jq -r '.items[] | select(.status.health.status != "Healthy") | .metadata.name' | while read app; do
              echo "=== $app ==="
              kubectl describe application $app -n argocd
            done
            exit 1
          fi

      - name: Run cluster validation using existing script
        run: |
          echo "Running comprehensive cluster validation..."
          echo ""
          
          # Make script executable
          chmod +x scripts/validate-cluster.sh
          
          # Run validation
          ./scripts/validate-cluster.sh

      - name: Show final cluster state
        if: always()
        run: |
          echo ""
          echo "=== Final Cluster State ==="
          echo ""
          echo "ArgoCD Applications:"
          kubectl get applications -n argocd
          echo ""
          echo "All Pods:"
          kubectl get pods -A
          echo ""
          echo "All Services:"
          kubectl get svc -A
          echo ""
          echo "Nodes:"
          kubectl get nodes

      - name: Collect logs on failure
        if: failure()
        run: |
          echo ""
          echo "=== Collecting logs for debugging ==="
          echo ""
          
          echo "ArgoCD Application Controller logs:"
          kubectl logs -n argocd -l app.kubernetes.io/name=argocd-application-controller --tail=100
          echo ""
          
          echo "ArgoCD Server logs:"
          kubectl logs -n argocd -l app.kubernetes.io/name=argocd-server --tail=100
          echo ""
          
          echo "External Secrets Operator logs:"
          kubectl logs -n external-secrets -l app.kubernetes.io/name=external-secrets --tail=100 || echo "ESO not running"
          echo ""
          
          echo "Failed pods:"
          kubectl get pods -A --field-selector=status.phase!=Running,status.phase!=Succeeded
          
          # Get logs from failed pods
          kubectl get pods -A --field-selector=status.phase!=Running,status.phase!=Succeeded -o json | \
            jq -r '.items[] | "\(.metadata.namespace) \(.metadata.name)"' | \
            while read ns pod; do
              echo ""
              echo "=== Logs for $ns/$pod ==="
              kubectl logs -n $ns $pod --tail=50 || true
            done

      - name: Cleanup test cluster
        if: always()
        run: |
          echo "Cleaning up test cluster..."
          k3d cluster delete test-platform || true
          echo "✓ Cleanup complete"

      - name: Summary
        if: success()
        run: |
          echo ""
          echo "╔══════════════════════════════════════════════════════════════╗"
          echo "║          ✓ Platform Integration Test PASSED                 ║"
          echo "╚══════════════════════════════════════════════════════════════╝"
          echo ""
          echo "All validations passed:"
          echo "  ✓ ArgoCD installed and configured"
          echo "  ✓ All platform applications synced from feature branch"
          echo "  ✓ All applications healthy"
          echo "  ✓ External Secrets synced successfully"
          echo "  ✓ No configuration drift detected"
          echo ""
          echo "This PR is safe to merge to main!"
