# Requirements Document: EventDrivenService Platform API

## Introduction

This specification defines requirements for creating a reusable EventDrivenService platform API in the zerotouch-platform repository. The EventDrivenService API enables platform consumers to deploy NATS JetStream event-driven worker services with KEDA autoscaling using a declarative Crossplane-based API.

**Context:** The platform successfully deployed the agent-executor service using direct Kubernetes manifests (212 lines). This specification creates a reusable abstraction to reduce future NATS-based service deployments from 212 lines to approximately 30 lines while maintaining Zero-Touch principles.

**Scope:** This API creates Deployment, Service, KEDA ScaledObject, and ServiceAccount resources. It does NOT provision database claims, cache claims, NATS streams, or secrets (these remain consumer responsibilities).

**Reference Implementation:** `bizmatters/services/agent_executor/` (deployed and verified)

---

## Glossary

- **EventDrivenService API**: Crossplane XRD enabling declarative deployment of NATS consumer services with KEDA autoscaling
- **Platform Repository**: Public zerotouch-platform repository containing infrastructure definitions
- **Consumer**: Developer or team deploying event-driven services on the platform
- **XRD**: Crossplane Composite Resource Definition defining the API contract
- **Composition**: Crossplane template provisioning Kubernetes resources based on XRD claims
- **NATS**: Lightweight messaging system for event-driven communication
- **JetStream**: NATS persistence layer for reliable message streaming
- **KEDA**: Kubernetes Event-Driven Autoscaling for scaling based on NATS queue depth
- **Zero-Touch**: Platform principle requiring crash-only recovery from Git without manual intervention
- **Crossplane**: Kubernetes-native infrastructure provisioning engine using XRDs and Compositions
- **ESO**: External Secrets Operator syncing secrets from AWS SSM Parameter Store
- **Init Container**: Kubernetes container running before main container starts (typically for migrations)
- **Hybrid Secret Approach**: Pattern accepting multiple secrets from different sources (Crossplane + ESO)

---

## Infrastructure Context

**Deployment Environment:**
- Orchestration: Talos Linux Kubernetes cluster (immutable, API-only)
- GitOps: ArgoCD with automated sync, prune, and selfHeal

**Data Layer:**
- Database: PostgreSQL via CloudNativePG Operator (Crossplane-managed)
- Cache: Dragonfly (Redis-compatible) via StatefulSet (Crossplane-managed)
- Message Queue: NATS with JetStream enabled (deployed in `nats` namespace)

**Security Infrastructure:**
- Secrets Management: External Secrets Operator (ESO) syncing from AWS SSM Parameter Store
- Database Credentials: Auto-generated by Crossplane PostgresInstance claims
- Cache Credentials: Auto-generated by Crossplane DragonflyInstance claims
- Image Registry: Private GitHub Container Registry (GHCR) with ESO-synced pull secrets

**Observability Stack:**
- Logging: Structured JSON logs (application-level)
- Metrics: Prometheus (planned, not yet deployed)
- Tracing: OpenTelemetry (planned, agent-executor emits traces to localhost:4317)

**Infrastructure as Code:**
- Platform APIs: Crossplane XRDs and Compositions
- Deployment: ArgoCD Applications with sync-wave ordering
- Security: Pod Security Standards enforced, no privileged containers

---

## Requirements

### Requirement 1: NATS Deployment

**User Story:** As a platform engineer, I want NATS deployed with JetStream enabled in the foundation layer, so that consumers can use reliable message streaming for their event-driven services.

#### Acceptance Criteria

1. THE platform SHALL deploy NATS using an ArgoCD Application at `bootstrap/components/01-nats.yaml`
2. THE NATS deployment SHALL use the official NATS Helm chart from https://nats-io.github.io/k8s/helm/charts/
3. THE NATS deployment SHALL enable JetStream for persistent streaming
4. THE NATS server SHALL be deployed in a dedicated `nats` namespace
5. THE NATS Application SHALL use sync-wave annotation "0" to deploy before all other platform layers

**Status:** ✅ Already deployed and verified

---

### Requirement 2: XRD Definition

**User Story:** As a platform engineer, I want an EventDrivenService XRD defined in the 04-apis layer, so that consumers have a declarative API for deploying event-driven worker services.

#### Acceptance Criteria

1. THE XRD SHALL be defined at `platform/04-apis/definitions/xeventdrivenservices.yaml`
2. THE XRD SHALL use API group `platform.bizmatters.io` with version `v1alpha1`
3. THE XRD SHALL define kind `XEventDrivenService` for composite resources
4. THE XRD SHALL define kind `EventDrivenService` for namespace-scoped claims
5. THE XRD schema SHALL include fields: `image`, `size`, `nats`, `secretRefs`, `imagePullSecrets`, `initContainer`

---

### Requirement 3: Image Configuration

**User Story:** As a platform consumer, I want to specify a container image for my service, so that the platform deploys my application code.

#### Acceptance Criteria

1. THE XRD SHALL define an `image` field of type string
2. THE `image` field SHALL be required
3. THE XRD SHALL accept fully-qualified image references including registry, repository, and tag
4. THE Composition SHALL use the `image` value for both init container and main container
5. WHERE the `image` tag is `latest`, THE Composition SHALL set `imagePullPolicy` to `Always`

**Security:**
- THE Composition SHALL configure `imagePullSecrets` when specified by consumer
- THE Composition SHALL support private container registries

---

### Requirement 4: Resource Sizing

**User Story:** As a platform consumer, I want to specify resource size as small/medium/large, so that I can easily request appropriate CPU and memory without knowing Kubernetes resource syntax.

#### Acceptance Criteria

1. THE XRD SHALL define a `size` field with enum values: `small`, `medium`, `large`
2. WHERE `size` is not specified, THEN THE Composition SHALL default to `medium`
3. WHEN `size` is `small`, THE Composition SHALL allocate 250m CPU request, 1000m CPU limit, 512Mi memory request, 2Gi memory limit
4. WHEN `size` is `medium`, THE Composition SHALL allocate 500m CPU request, 2000m CPU limit, 1Gi memory request, 4Gi memory limit
5. WHEN `size` is `large`, THE Composition SHALL allocate 1000m CPU request, 4000m CPU limit, 2Gi memory request, 8Gi memory limit

**Performance:**
- THE Composition SHALL set both requests and limits for predictable pod scheduling
- THE resource allocations SHALL be based on proven agent-executor production tuning

---

### Requirement 5: NATS Configuration

**User Story:** As a platform consumer, I want to configure NATS stream and consumer group, so that my service consumes messages from the correct queue.

#### Acceptance Criteria

1. THE XRD SHALL define a `nats` object with fields: `url`, `stream`, `consumer`
2. THE `nats.url` field SHALL default to `nats://nats.nats.svc:4222`
3. THE `nats.stream` field SHALL be required and specify the JetStream stream name
4. THE `nats.consumer` field SHALL be required and specify the consumer group name
5. THE Composition SHALL inject `nats.url`, `nats.stream`, and `nats.consumer` as environment variables `NATS_URL`, `NATS_STREAM_NAME`, `NATS_CONSUMER_GROUP`

**Reliability:**
- THE platform SHALL NOT create NATS streams (consumer responsibility via Job)
- THE Composition SHALL NOT validate stream existence at claim creation time

---

### Requirement 6: Hybrid Secret References

**User Story:** As a platform consumer, I want to reference multiple secrets from different sources (Crossplane, ESO, manual), so that I can use auto-generated database credentials alongside application secrets without consolidation.

#### Acceptance Criteria

1. THE XRD SHALL define a `secretRefs` array containing secret reference objects
2. THE secret reference object SHALL include fields: `name` (required), `env` (array of key mappings), `envFrom` (boolean)
3. WHEN `envFrom` is `true`, THE Composition SHALL mount all secret keys as environment variables using `envFrom`
4. WHEN `env` array is specified, THE Composition SHALL mount each listed key to the specified environment variable name using `secretKeyRef`
5. WHERE `secretRefs` is empty, THEN THE Composition SHALL create the Deployment without secret mounts

**Security:**
- THE Composition SHALL NOT create secrets (Crossplane/ESO responsibility)
- THE Composition SHALL reference secrets by name only
- IF a referenced secret does not exist, THEN Kubernetes SHALL fail to start the pod

**Example:**
```yaml
secretRefs:
  - name: my-service-db-conn  # Crossplane-generated
    env:
      - secretKey: endpoint
        envName: POSTGRES_HOST
      - secretKey: port
        envName: POSTGRES_PORT
  - name: my-service-llm-keys  # ESO-synced
    envFrom: true  # Mount all keys as-is
```

---

### Requirement 7: Image Pull Secrets

**User Story:** As a platform consumer, I want to use private container registries, so that I can deploy proprietary application code on the platform.

#### Acceptance Criteria

1. THE XRD SHALL define an `imagePullSecrets` array containing secret names
2. THE Composition SHALL configure `imagePullSecrets` in the Deployment spec
3. WHERE `imagePullSecrets` is empty, THEN THE Deployment SHALL use default service account credentials
4. THE Composition SHALL support multiple `imagePullSecrets` for different registries
5. THE platform SHALL NOT create image pull secrets (ESO responsibility)

**Security:**
- THE Composition SHALL reference image pull secrets by name only
- IF an image pull secret does not exist, THEN Kubernetes SHALL report `ImagePullBackOff` error

---

### Requirement 8: Init Container for Migrations

**User Story:** As a platform consumer, I want an optional init container that runs database migrations, so that schema changes are applied automatically before my service starts.

#### Acceptance Criteria

1. THE XRD SHALL define an optional `initContainer` object with fields: `command` (array), `args` (array)
2. WHERE `initContainer` is specified, THE Composition SHALL create an init container using the same `image` as the main container
3. WHERE `initContainer` is NOT specified, THE Composition SHALL create the Deployment without an init container
4. THE init container SHALL have access to the same `secretRefs` environment variables as the main container
5. IF the init container exits with non-zero status, THEN Kubernetes SHALL NOT start the main container

**Reliability:**
- THE Deployment SHALL report init container failures in pod events
- THE init container SHALL use the same `imagePullSecrets` as the main container

**Example:**
```yaml
initContainer:
  command: ["/bin/bash", "-c"]
  args: ["cd /app && ./scripts/ci/run-migrations.sh"]
```

---

### Requirement 9: Deployment Resource

**User Story:** As a platform engineer, I want the Composition to create a Deployment with appropriate configuration, so that the consumer's service runs reliably in Kubernetes.

#### Acceptance Criteria

1. THE Composition SHALL create a Kubernetes Deployment resource
2. THE Deployment SHALL use the consumer-specified `image`
3. THE Deployment SHALL configure resource requests and limits based on the `size` field
4. THE Deployment SHALL mount secrets according to the `secretRefs` configuration
5. THE Deployment SHALL set `imagePullSecrets` when specified

**Security:**
- THE Deployment SHALL configure pod security context: `runAsNonRoot: true`, `runAsUser: 1000`, `allowPrivilegeEscalation: false`
- THE Deployment SHALL drop all Linux capabilities
- THE Deployment SHALL use `seccompProfile: {type: RuntimeDefault}`

**Reliability:**
- THE Deployment SHALL set replicas to 1 (KEDA controls scaling)
- THE Deployment SHALL use `RollingUpdate` strategy

---

### Requirement 10: Service Resource

**User Story:** As a platform engineer, I want the Composition to create a ClusterIP Service, so that the deployed service is accessible within the cluster.

#### Acceptance Criteria

1. THE Composition SHALL create a Kubernetes Service resource
2. THE Service SHALL be of type `ClusterIP`
3. THE Service SHALL expose port 8080 targeting container port 8080
4. THE Service SHALL use selector labels matching the Deployment pods
5. THE Service SHALL be named `{claim-name}` matching the claim metadata name

---

### Requirement 11: Health and Readiness Probes

**User Story:** As a platform consumer, I want health and readiness probes configured, so that Kubernetes can manage my service lifecycle automatically.

#### Acceptance Criteria

1. THE Composition SHALL configure an HTTP liveness probe on path `/health` port 8080
2. THE liveness probe SHALL use `initialDelaySeconds: 10`, `periodSeconds: 10`, `timeoutSeconds: 5`, `failureThreshold: 3`
3. THE Composition SHALL configure an HTTP readiness probe on path `/ready` port 8080
4. THE readiness probe SHALL use `initialDelaySeconds: 5`, `periodSeconds: 5`, `timeoutSeconds: 3`, `failureThreshold: 2`
5. THE consumer service SHALL implement `/health` and `/ready` HTTP endpoints

**Reliability:**
- WHEN the liveness probe fails 3 consecutive times, Kubernetes SHALL restart the pod
- WHEN the readiness probe fails, Kubernetes SHALL remove the pod from Service endpoints

---

### Requirement 12: KEDA ScaledObject

**User Story:** As a platform consumer, I want KEDA autoscaling based on NATS queue depth, so that my service scales automatically with workload.

#### Acceptance Criteria

1. THE Composition SHALL create a KEDA ScaledObject resource
2. THE ScaledObject SHALL use trigger type `nats-jetstream`
3. THE ScaledObject SHALL configure `natsServerMonitoringEndpoint` as `nats-headless.nats.svc.cluster.local:8222`
4. THE ScaledObject SHALL monitor the stream specified in `nats.stream` field
5. THE ScaledObject SHALL monitor the consumer specified in `nats.consumer` field

**Performance:**
- THE ScaledObject SHALL set `lagThreshold` to 5 messages
- THE ScaledObject SHALL set `minReplicaCount` to 1
- THE ScaledObject SHALL set `maxReplicaCount` to 10
- THE ScaledObject SHALL configure `account: "$SYS"` for NATS monitoring

**Critical Fix:**
- THE Composition SHALL use `nats-headless` service (port 8222 exposed), NOT `nats` service (port 8222 not exposed)

---

### Requirement 13: ServiceAccount

**User Story:** As a platform engineer, I want the Composition to create a ServiceAccount for pod identity, so that services can use Kubernetes RBAC if needed.

#### Acceptance Criteria

1. THE Composition SHALL create a Kubernetes ServiceAccount resource
2. THE ServiceAccount SHALL be named `{claim-name}`
3. THE Deployment SHALL reference the created ServiceAccount
4. WHERE additional RBAC permissions are needed, THE consumer SHALL create Role and RoleBinding separately
5. THE ServiceAccount SHALL NOT have any default permissions beyond standard pod execution

---

### Requirement 14: ArgoCD Application for 04-apis Layer

**User Story:** As a platform engineer, I want the 04-apis layer enabled in ArgoCD, so that XRDs and Compositions are automatically deployed to the cluster.

#### Acceptance Criteria

1. THE platform SHALL enable the 04-apis layer by renaming `platform/04-apis.yaml.disabled` to `platform/04-apis.yaml`
2. THE 04-apis ArgoCD Application SHALL use sync-wave annotation "1" to deploy after foundation (wave 0)
3. THE 04-apis Application SHALL sync from `platform/04-apis` directory
4. THE 04-apis Application SHALL configure automated sync with `prune: true` and `selfHeal: true`
5. WHEN XRD or Composition changes are committed to Git, ArgoCD SHALL sync automatically within 3 minutes

**Documentation:**
- THE platform SHALL document the 04-apis layer in `platform/04-apis/README.md`

---

### Requirement 15: Standard Labels and Naming

**User Story:** As a platform engineer, I want consistent labels and naming conventions applied to all resources, so that resources can be queried and monitored using standard selectors.

#### Acceptance Criteria

1. THE Composition SHALL apply label `app.kubernetes.io/name` with value `{claim-name}` to all created resources
2. THE Composition SHALL apply label `app.kubernetes.io/component` with value `event-driven-worker` to all created resources
3. THE Composition SHALL apply label `app.kubernetes.io/managed-by` with value `crossplane` to all created resources
4. THE Composition SHALL name resources using pattern `{claim-name}` for Deployment, Service, ServiceAccount
5. THE Composition SHALL name KEDA ScaledObject using pattern `{claim-name}-scaler`

**Observability:**
- THE labels SHALL enable Prometheus to scrape metrics using standard label selectors
- THE labels SHALL enable kubectl queries like `kubectl get pods -l app.kubernetes.io/name=my-service`

---

### Requirement 16: API Documentation

**User Story:** As a platform consumer, I want comprehensive API documentation, so that I can deploy services without reading implementation code.

#### Acceptance Criteria

1. THE platform SHALL provide API documentation at `platform/04-apis/README.md`
2. THE documentation SHALL include the complete XRD schema with field descriptions
3. THE documentation SHALL provide example claims for small, medium, and large services
4. THE documentation SHALL document the `secretRefs` hybrid approach with Crossplane and ESO examples
5. THE documentation SHALL include troubleshooting guidance for common issues (ImagePullBackOff, secret not found, KEDA trigger errors)

**Examples Required:**
- Minimal claim (image + NATS only, no secrets)
- Full claim (image + NATS + database + cache + LLM keys + init container)
- Migration from direct manifests to EventDrivenService API

---

### Requirement 17: Validation and Testing

**User Story:** As a platform engineer, I want the EventDrivenService API validated with the agent-executor reference implementation, so that I can verify the API produces identical resources to the current direct manifests.

#### Acceptance Criteria

1. THE platform SHALL create an EventDrivenService claim for agent-executor at `platform/04-apis/examples/agent-executor-claim.yaml`
2. THE Composition SHALL produce Deployment, Service, and KEDA ScaledObject resources matching the current agent-executor deployment
3. THE validation SHALL compare resource specifications field-by-field (image, resources, env vars, probes, KEDA config)
4. WHERE differences exist, THE platform SHALL document the rationale (e.g., standardized labels added)
5. THE KEDA ScaledObject SHALL use `nats-headless.nats.svc.cluster.local:8222` endpoint (proven fix)

**Testing:**
- THE platform SHALL verify KEDA autoscaling works identically to the current agent-executor setup
- THE platform SHALL verify init container migrations execute successfully
- THE platform SHALL verify all secrets mount correctly from Crossplane and ESO

---

### Requirement 18: Migration Path

**User Story:** As a platform consumer, I want a documented migration path from direct manifests to the EventDrivenService API, so that I can transition existing services safely.

#### Acceptance Criteria

1. THE platform SHALL document the migration process in `platform/04-apis/README.md`
2. THE migration guide SHALL list prerequisites (existing secrets, database claims, NATS streams)
3. THE migration guide SHALL provide step-by-step instructions to convert direct Deployment to EventDrivenService claim
4. THE migration guide SHALL document the rollback procedure
5. THE migration guide SHALL explain how to verify the migration succeeded

**Safety:**
- THE migration SHALL be reversible (can switch back to direct manifests)
- THE migration SHALL NOT require downtime
- THE migration SHALL preserve existing secret references and environment variables

---

### Requirement 19: Security Compliance

**User Story:** As a platform engineer, I want all deployed services to comply with Kubernetes security best practices, so that the platform maintains a secure posture.

#### Acceptance Criteria

1. THE Composition SHALL configure pod security context: `runAsNonRoot: true`, `runAsUser: 1000`
2. THE Composition SHALL set `allowPrivilegeEscalation: false` for all containers
3. THE Composition SHALL drop all Linux capabilities using `capabilities: {drop: [ALL]}`
4. THE Composition SHALL configure `seccompProfile: {type: RuntimeDefault}`
5. THE Composition SHALL NOT mount the service account token automatically (`automountServiceAccountToken: false`)

**Compliance:**
- THE deployed pods SHALL pass Kubernetes Pod Security Standards (Restricted policy)
- THE deployed pods SHALL pass security scanning by admission controllers

---

### Requirement 20: Error Handling and Observability

**User Story:** As a platform consumer, I want clear error messages when my claim fails to provision, so that I can debug issues quickly.

#### Acceptance Criteria

1. WHEN a referenced secret does not exist, Kubernetes SHALL report `CreateContainerConfigError` with the missing secret name
2. WHEN an image pull fails, Kubernetes SHALL report `ImagePullBackOff` with the image reference and error details
3. WHEN the init container fails, Kubernetes SHALL report the exit code and logs in pod events
4. WHEN KEDA cannot connect to NATS, KEDA SHALL report `TriggerError` with connection details in ScaledObject status
5. THE Composition SHALL propagate all Kubernetes events to the EventDrivenService claim status

**Observability:**
- THE platform SHALL document how to check claim status: `kubectl get eventdrivenservice <name> -o yaml`
- THE platform SHALL document how to check pod events: `kubectl describe pod <pod-name>`
- THE platform SHALL document how to check KEDA ScaledObject status: `kubectl get scaledobject <name> -o yaml`

---

### Requirement 21: Schema Publication and Developer Tooling

**User Story:** As an app team developer, I want the EventDrivenService API schema published as OpenAPI/JSON Schema with validation tooling, so that I can validate claims locally, get IDE autocomplete, and explore the API interactively.

#### Acceptance Criteria

1. THE platform SHALL extract the OpenAPI v3 schema from the XRD and publish it at `platform/04-apis/schemas/eventdrivenservice.schema.json`
2. THE schema file SHALL be valid JSON Schema Draft 2020-12 compatible with standard validation tools
3. THE platform SHALL provide a script at `scripts/validate-claim.sh` that validates EventDrivenService claims against the schema
4. THE validation script SHALL be integrated into CI/CD to prevent invalid claims from being merged
5. WHERE an invalid claim is submitted, THE validation script SHALL output clear error messages indicating which fields are invalid and why

**Developer Experience:**
- THE platform documentation SHALL include instructions for IDE integration (VSCode YAML extension, IntelliJ)
- THE schema SHALL enable IDE autocomplete for EventDrivenService claim fields
- THE platform MAY deploy Swagger UI for interactive API exploration (optional enhancement)

**Testing:**
- ALL example claims in `platform/04-apis/examples/` SHALL be validated against the schema in CI
- THE platform SHALL provide a test suite validating that the Composition produces expected resources for example claims
- THE validation SHALL fail the build if example claims do not conform to the schema

**Rationale:**
- Schema validation prevents deployment-time errors (fail fast in CI)
- IDE autocomplete reduces developer errors and onboarding time
- Published schema enables external tooling (linters, generators, documentation sites)
- Validates platform API contract before runtime

---

## Production-Ready Checklist

### Security & Compliance
- ✅ **Input Validation:** XRD schema validates all claim fields (string, enum, required)
- ✅ **Secrets Management:** Composition references secrets created by Crossplane/ESO (Zero-Touch)
- ✅ **Pod Security:** Composition enforces Pod Security Standards (runAsNonRoot, drop capabilities, seccompProfile)
- ✅ **Image Security:** Composition supports private registries via imagePullSecrets
- N/A **Authentication:** Services implement their own authentication (platform does not enforce)
- N/A **Authorization:** Services implement their own authorization (platform does not enforce)
- N/A **Encryption:** Service-to-service communication security is consumer responsibility
- N/A **Audit Logging:** Application-level audit logging is consumer responsibility

### Observability
- ✅ **Error Reporting:** Composition propagates Kubernetes events to claim status
- ✅ **Metrics:** Services must expose `/metrics` endpoint (consumer responsibility)
- ✅ **Tracing:** Services may emit OpenTelemetry traces (consumer responsibility)
- ✅ **Dashboards:** Standardized labels enable Prometheus/Grafana monitoring
- ⚠️ **Logging:** Structured JSON logging is consumer responsibility (documented in API README)

### Reliability & Performance
- ✅ **Resource Limits:** Composition sets CPU/memory requests and limits based on size
- ✅ **Health Probes:** Composition configures liveness and readiness probes
- ✅ **Autoscaling:** KEDA ScaledObject scales based on NATS queue depth (1-10 replicas)
- ✅ **Init Containers:** Optional init container for database migrations
- N/A **Idempotency:** Consumer services implement idempotent message processing
- N/A **Backup:** Database backups managed by CloudNativePG Operator (separate)

### Documentation & DevOps
- ✅ **API Specification:** XRD serves as API contract (OpenAPI-like schema)
- ✅ **Schema Publication:** JSON Schema published for IDE autocomplete and validation (Requirement 21)
- ✅ **Schema Validation:** CI/CD validates claims against schema before merge (Requirement 21)
- ✅ **Infrastructure:** Composition created in platform/04-apis (GitOps-managed)
- ✅ **Examples:** API README includes example claims for different scenarios
- ✅ **Runbooks:** Troubleshooting guide in API README
- ✅ **Migration Guide:** Step-by-step migration from direct manifests documented
- ⚠️ **Testing:** Validation with agent-executor reference implementation (Requirement 17)

---

## Document Metadata

**Version:** 1.0.0
**Last Updated:** 2025-12-08
**Author:** Platform Team
**Status:** Awaiting Review
**Reference:** ARCHITECTURE_DECISION.md
